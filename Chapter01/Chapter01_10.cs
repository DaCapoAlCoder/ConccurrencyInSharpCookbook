using Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reactive.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Chapter01
{
    public class Chapter01_10 : IChapter
    {
        public void Run()
        {
            // Reactive programming allows treating a stream of events like a stream of data
            // If events are used in a program where the event arguments are also used,
            // these events would be good candidates for migrating to a System.Reactive
            // implementation. 

            // The structure of a stream is as follows:
            // interface IObservable<in T>
            // {
            //     void OnNext(T item);
            //     void OnCompleted();
            //     OnError(Exception error);
            // }

            // Some observable streams will end, which will result in the OnCompleted method
            // being called, some will never end, which will mean OnNext will always be called
            // for each observable event that gets pushed through the pipeline. When an
            // exception occurs OnError will be called

            Test();
            Test2();
            Test3();

            // Subjects are like manual observables where OnNext, OnError and OnCompleted can
            // be called causing the corresponding delegates on the subscriber to be triggered
            // It can be a useful tool when experimenting with observables. For production
            // however strive to use existing observable implementations
        }

        void Test()
        {
            // Observables look like linq statements. Linq to Entities e.g. Entity Framework
            // and Linq to Objects (linq query on IEnumerable) pull data through the query
            // from the source, such as an IEnumerable collection or a Database. System.Reactive
            // pushes events through the query in what could be considered linq to events.

            // This is a non ending observable stream of events. However Take was added
            // so that it would complete and all of the examples would run
            var observable = Observable.Interval(TimeSpan.FromSeconds(1))
                .Take(5)
                .Timestamp()
                .Where(x => x.Value % 2 == 0)
                .Select(x => x.Timestamp);

            // This code was added to block the thread and wait for the observable
            // to complete
            using (observable.Subscribe(x => Console.WriteLine(x)))
            {
                observable.Wait();
            }

        }

        void Test2()
        {
            // This example demonstrates that observables are separate
            // from their subscriptions. The Observable is created and then
            // later observed by subscribing to it. The events generated by
            // Interval still fire event without an observer. This type of
            // stream is referred to as a hot observable. A cold observable
            // must have a subscriber to trigger the event, such as 
            // subscribing to a Http download

            IObservable<DateTimeOffset> timestamps =
                Observable.Interval(TimeSpan.FromSeconds(1))
                    .Take(5)
                    .Timestamp()
                    .Where(x => x.Value % 2 == 0)
                    .Select(x => x.Timestamp);

            // Subscribe returns an IDisposable, when done listening, dispose
            // of the subscription
            using (timestamps.Subscribe(x => Console.WriteLine(x)))
            {
                timestamps.Wait();
            }
        }

        void Test3()
        {
            var observable = Observable.Interval(TimeSpan.FromSeconds(1))
                .Take(5)
                .Timestamp()
                .Where(x => x.Value % 2 == 0)
                .Select(x => x.Timestamp);


            // A subscriber should always take an error handling delegate in case
            // the stream ends in exception
            using (observable.Subscribe(
                x => Console.WriteLine(x), 
                ex => Console.WriteLine(ex)))
            {
                observable.Wait();
            }
        }
    }
}
